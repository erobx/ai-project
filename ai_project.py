# -*- coding: utf-8 -*-
"""AI_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RRfczt61JykCBAl4F-r1lyZXgZuXYjEK

**Evan Robinson 100530274**

"""

import numpy as np
import skfuzzy as fuzz
import matplotlib.pyplot as plt
from MFIS_Read_Functions import readFuzzySetsFile, readRulesFile, readApplicationsFile, readRiskFile
from MFIS_Classes import Application

"""We load the sets from the given functions, slightly modified to also load the data from the Risks.txt file."""

files_path = 'files/'
fuzzySetsDict = readFuzzySetsFile(files_path + '/InputVarSets.txt')
ruleList = readRulesFile(files_path + '/Rules.txt')
applications = readApplicationsFile(files_path + '/Applications.txt')
riskSetDict = readRiskFile(files_path + '/Risks.txt')

def get_sets(fuzzySetDict, var):
  result = []
  for fs in fuzzySetDict.values():
    if fs.var == var:
      result.append(fs)

  return result

def plot_sets(sets, ax):
  colors = ['b', 'r', 'g', 'y']
  i = 0
  for s in sets:
    ax.plot(s.x, s.y, colors[i], linewidth=1.5, label=s.label)
    i += 1

  ax.set_title(sets[0].var)
  ax.legend()

def plot_details(ax):
  ax.spines['top'].set_visible(False)
  ax.spines['right'].set_visible(False)
  ax.get_xaxis().tick_bottom()
  ax.get_yaxis().tick_left()

"""We plot the unvierse and membership functions for each set."""

def plot_funcs():
  fig, (ax0, ax1, ax2, ax3, ax4, ax5, ax6) = plt.subplots(nrows=7, figsize=(11,9))

  sets = get_sets(fuzzySetsDict, 'Age')
  plot_sets(sets, ax0)
  sets = get_sets(fuzzySetsDict, 'IncomeLevel')
  plot_sets(sets, ax1)
  sets = get_sets(fuzzySetsDict, 'Assets')
  plot_sets(sets, ax2)
  sets = get_sets(fuzzySetsDict, 'Amount')
  plot_sets(sets, ax3)
  sets = get_sets(fuzzySetsDict, 'Job')
  plot_sets(sets, ax4)
  sets = get_sets(fuzzySetsDict, 'History')
  plot_sets(sets, ax5)
  sets = get_sets(riskSetDict, 'Risk')
  plot_sets(sets, ax6)

  for ax in (ax0, ax1, ax2, ax3, ax4, ax5):
    plot_details(ax)

  plt.tight_layout()
  plt.show()


def define_membership(var: str, data):
  membership = {}
  sets = get_sets(fuzzySetsDict, var)
  for s in sets:
    key = var + '=' + s.label
    m = fuzz.interp_membership(s.x, s.y, data)
    s.memDegree = m
    membership[key] = m

  return membership

"""Here we create a map of fuzzy membership functions for each application."""


def get_memberships(app: Application):
  memberships = {}
  age = app.data[0][1]
  income_level = app.data[1][1]
  assets = app.data[2][1]
  amount = app.data[3][1]
  job = app.data[4][1]
  history = app.data[5][1]
  memberships.update(define_membership('Age', age))
  memberships.update(define_membership('IncomeLevel', income_level))
  memberships.update(define_membership('Assets', assets))
  memberships.update(define_membership('Amount', amount))
  memberships.update(define_membership('Job', job))
  memberships.update(define_membership('History', history))
  memberships['Risk=LowR'] = riskSetDict['Risk=LowR'].y
  memberships['Risk=MediumR'] = riskSetDict['Risk=MediumR'].y
  memberships['Risk=HighR'] = riskSetDict['Risk=HighR'].y
  return memberships

"""Rule strengths are determined by taking the AND (min) of the fuzzy membership functions for each antecedent and then clipping them to the min of the rule consequent."""

def apply_rules(memberships: dict):
  for rule in ruleList:
    val = 1.1
    if len(rule.antecedent) != 1:
      for a in rule.antecedent:
        val = np.fmin(memberships[a], val)
      activation = np.fmin(val, memberships[rule.consequent]) # Clip
      rule.strength = activation
    else:
      activation = np.fmin(memberships[rule.antecedent[0]], memberships[rule.consequent])
      rule.strength = activation

"""We now aggregate the rule strengths using the max operator."""

def get_output_dist(app: Application):
  memberships = get_memberships(app)
  apply_rules(memberships)
  aggregate = -0.1
  for rule in ruleList:
    aggregate = np.fmax(rule.strength, aggregate)

  return aggregate

def plot_risk(risk, x_risk, aggregated, risk_activation):
  risk0 = np.zeros_like(x_risk)
  fig, ax0 = plt.subplots(figsize=(8,3))

  ax0.plot(x_risk, riskSetDict['Risk=LowR'].y, 'b', linewidth=0.5, linestyle='--', )
  ax0.plot(x_risk, riskSetDict['Risk=MediumR'].y, 'g', linewidth=0.5, linestyle='--')
  ax0.plot(x_risk, riskSetDict['Risk=HighR'].y, 'r', linewidth=0.5, linestyle='--')
  ax0.fill_between(x_risk, risk0, aggregated, facecolor='Orange', alpha=0.7)
  ax0.plot([risk, risk], [0, risk_activation], 'k', linewidth=1.5, alpha=0.9)
  ax0.set_title('Aggregated membership and result (line)')

  for ax in (ax0, ):
    plot_details(ax)

  plt.tight_layout()
  plt.show()


"""Finally, we process each application and write each to the file, Results.txt, with its calculated risk value. We also display the aggregated membership and result below."""

def main():
  plot_funcs()

  with open('Results.txt', 'w') as f:
    for app in applications:
      aggregate = get_output_dist(app)
      x_risk = riskSetDict['Risk=LowR'].x
      risk = fuzz.defuzz(x_risk, aggregate, 'centroid')
      s_risk = '%.2f' % risk
      f.write("App: " + app.appId + ", Risk: " + s_risk + "%\n")
      risk_activation = fuzz.interp_membership(x_risk, aggregate, risk)
      # plot_risk(ax, risk, x_risk, aggregate, risk_activation) # WARNING: Will open 50 individual windows

  f.close()


if __name__ == main():
  main()